<!DOCTYPE html>
<html>
  <head>
    <base target="_top">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
      tailwind.config = {
        theme: {
          extend: {
            colors: {
              brand: {
                50: '#f8fafc',
                100: '#f1f5f9',
                500: '#64748b',
                600: '#475569',
                700: '#334155',
                800: '#1e293b',
                900: '#0f172a'
              },
              zotoks: {
                50: '#f0f9ff',
                100: '#e0f2fe',
                500: '#0ea5e9',
                600: '#0284c7',
                700: '#0369a1',
                900: '#0c4a6e'
              },
              accent: {
                50: '#eff6ff',
                100: '#dbeafe',
                500: '#3b82f6',
                600: '#2563eb',
                700: '#1d4ed8'
              }
            }
          }
        }
      }
    </script>
    <style>
      .mapping-grid {
        display: grid;
        grid-template-columns: 1fr auto 1fr;
        gap: 1rem;
        align-items: center;
      }
      .fade-in {
        animation: fadeIn 0.3s ease-out;
      }
      @keyframes fadeIn {
        from { opacity: 0; transform: translateY(8px); }
        to { opacity: 1; transform: translateY(0); }
      }
      
      /* Sync button animations */
      .sync-arrow {
        transition: all 0.3s ease;
      }
      
      .sync-button-pressed .sync-arrow {
        animation: syncSpin 1.5s ease-in-out infinite;
      }
      
      @keyframes syncSpin {
        0% { transform: rotate(0deg) scale(1); }
        25% { transform: rotate(180deg) scale(1.1); }
        50% { transform: rotate(360deg) scale(1); }
        75% { transform: rotate(540deg) scale(1.1); }
        100% { transform: rotate(720deg) scale(1); }
      }
      
      .sync-button-pressed {
        animation: buttonPulse 0.2s ease-out;
      }
      
      @keyframes buttonPulse {
        0% { transform: scale(1); }
        50% { transform: scale(0.95); }
        100% { transform: scale(1); }
      }
    </style>
  </head>
  <body class="bg-slate-50 text-slate-900">
    <div class="w-full h-screen flex flex-col max-w-7xl mx-auto bg-white">

      <!-- Header -->
      <div class="flex-none bg-white border-b border-slate-200 px-6 py-2">
        <div class="flex items-center justify-between">
          <div class="flex items-center gap-3">
            <div class="w-10 h-10 bg-zotoks-100 rounded-lg flex items-center justify-center">
              <svg class="w-5 h-5 text-zotoks-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 7h12m0 0l-4-4m4 4l-4 4"></path>
              </svg>
            </div>
            <div>
              <h1 class="text-lg font-semibold text-slate-900">Zötok Column Mapping</h1>
              <p class="text-sm text-slate-600">
                Sheet: <span id="sheetName" class="font-medium text-slate-900">--</span> • 
                Data: <span id="dataSource" class="font-medium text-zotoks-600">--</span>
              </p>
            </div>
          </div>
          <div class="flex items-center gap-3">
            <button onclick="autoMapColumns()" 
                    class="px-4 py-2 bg-zotoks-600 text-white rounded-md font-medium hover:bg-zotoks-700 transition-colors flex items-center gap-2 text-sm">
              <svg class="w-4 h-4 sync-arrow" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 10V3L4 14h7v7l9-11h-7z"></path>
              </svg>
              Auto Map
            </button>
            <div class="text-sm text-slate-500">
              <span class="inline-flex items-center gap-1">
                <div class="w-2 h-2 bg-green-500 rounded-full"></div>
                <span class="font-medium text-green-600" id="mappedCount">0</span> mapped
              </span>
              <span class="mx-2">•</span>
              <span class="inline-flex items-center gap-1">
                <div class="w-2 h-2 bg-amber-500 rounded-full"></div>
                <span class="font-medium text-amber-600" id="unmappedCount">0</span> unmapped
              </span>
            </div>
          </div>
        </div>
      </div>

      <!-- Main Content -->
      <div class="flex-1 flex min-h-0">
        
        <!-- Mapping Panel -->
        <div class="w-1/2 border-r border-slate-200 flex flex-col">
          <div class="flex-none px-6 py-2 bg-slate-50 border-b border-slate-200">
            <h2 class="font-medium text-slate-900">Source to Target Mapping</h2>
            <p class="text-xs text-slate-600">Map Zötok columns to your sheet columns</p>
          </div>

          <div class="flex-1 overflow-y-auto px-6 py-3 pb-16" id="mappingContainer">
            <!-- Mapping rows will be populated here -->
          </div>
        </div>
        
        <!-- Preview Panel -->
        <div class="w-1/2 flex flex-col">
          <div class="flex-none px-6 py-2 bg-slate-50 border-b border-slate-200">
            <div class="flex items-center justify-between">
              <div>
                <h2 class="font-medium text-slate-900">Data Preview</h2>
                <p class="text-xs text-slate-600">Live preview of mapped data</p>
              </div>
              <div class="text-sm text-slate-500">
                <span id="previewRows">0</span> sample rows • <span id="dataPeriod">--</span> days
              </div>
            </div>
          </div>

          <div class="flex-1 overflow-auto pb-16">
            <table class="w-full text-sm" id="previewTable">
              <!-- Preview table will be populated here -->
            </table>
          </div>
        </div>
      </div>

      <!-- Footer -->
      <div class="flex-none border-t border-slate-200 px-6 py-2 bg-white">
        <div class="flex justify-between items-center">
          <!-- Sync Notice -->
          <div class="text-xs text-slate-500 bg-zotoks-50 px-3 py-2 rounded-md border border-zotoks-200">
            <div class="flex items-center gap-2">
              <svg class="w-3 h-3 text-zotoks-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
              </svg>
              <span class="text-zotoks-700">Column mappings will be saved for future imports and exports to this sheet</span>
            </div>
          </div>
          
          <div class="flex gap-3">
            <button onclick="cancelMapping()" 
                    class="px-6 py-2 border border-slate-300 text-slate-700 rounded-md font-medium hover:bg-slate-50 transition-colors">
              Cancel
            </button>
            <button onclick="proceedWithMapping()"
                    id="proceedButton"
                    class="px-6 py-2 bg-zotoks-600 text-white rounded-md font-medium hover:bg-zotoks-700 transition-colors flex items-center gap-2">
              <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-8l-4-4m0 0L8 8m4-4v12"></path>
              </svg>
              <span id="buttonText">Import Data & Save Mappings</span>
            </button>
          </div>
        </div>
      </div>

      <!-- Loading Overlay -->
      <div class="loading hidden fixed inset-0 bg-white/90 backdrop-blur-sm z-50" id="loadingDiv">
        <div class="flex items-center justify-center h-full">
          <div class="bg-white rounded-lg shadow-lg border border-slate-200 p-8 text-center max-w-sm">
            <div class="w-8 h-8 border-2 border-slate-300 border-t-zotoks-600 rounded-full animate-spin mx-auto mb-4"></div>
            <h3 class="font-medium text-slate-900 mb-2" id="loadingTitle">Importing Zötok Data</h3>
            <p class="text-sm text-slate-600 mb-2" id="loadingMessage">Applying column mappings and importing your data...</p>
            <p class="text-xs text-zotoks-600">Mappings will be saved for future imports and exports to this sheet</p>
          </div>
        </div>
      </div>

      <!-- Success Overlay -->
      <div class="success hidden fixed inset-0 bg-white/90 backdrop-blur-sm z-50" id="successDiv">
        <div class="flex items-center justify-center h-full">
          <div class="bg-white rounded-lg shadow-lg border border-slate-200 p-8 text-center max-w-md">
            <div class="w-12 h-12 bg-green-100 rounded-full flex items-center justify-center mx-auto mb-4">
              <svg class="w-6 h-6 text-green-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"></path>
              </svg>
            </div>
            <h3 class="font-medium text-slate-900 mb-2" id="successTitle">Import Successful!</h3>
            <p class="text-sm text-slate-600 mb-2" id="successMessage">Data imported successfully</p>
            <p class="text-xs text-zotoks-600">Column mappings have been saved for future imports and exports to this sheet</p>
          </div>
        </div>
      </div>
    </div>

    <script>
      // Parse data from server
      const targetSheetName = '<?= targetSheetName ?>';
      const endpoint = '<?= endpoint ?>';
      const period = '<?= period ?>';
      const isExportMode = '<?= isExportMode ?>' === 'true';
      const sourceColumns = JSON.parse('<?= sourceColumns ?>');
      const targetColumns = JSON.parse('<?= targetColumns ?>');
      const sampleData = JSON.parse('<?= sampleData ?>');
      
      // Initialize page
      document.getElementById('sheetName').textContent = targetSheetName;
      document.getElementById('dataSource').textContent = endpoint.charAt(0).toUpperCase() + endpoint.slice(1);
      document.getElementById('dataPeriod').textContent = period;

      // Set button text based on mode
      if (isExportMode) {
        document.getElementById('buttonText').textContent = 'Upload Data & Save Mappings';
      } else {
        document.getElementById('buttonText').textContent = 'Import Data & Save Mappings';
      }
      
      // Create mapping interface
      function initializeMappings() {
        const container = document.getElementById('mappingContainer');

        // OPTIMIZATION 1: Pre-build target options HTML once (reuse for all rows)
        const targetOptionsHtml = targetColumns.map(col => `
          <li class="text-slate-900 cursor-default select-none relative py-2 pl-3 pr-9 hover:bg-zotoks-100" role="option" data-value="${col}">
            <span class="font-normal block truncate">${col}</span>
          </li>
        `).join('');

        // OPTIMIZATION 2: Build all rows as one HTML string (single DOM write)
        const allRowsHtml = sourceColumns.map((sourceCol) => {
          const sampleValue = sampleData.length > 0 && sampleData[0][sourceCol] !== undefined
            ? String(sampleData[0][sourceCol]).substring(0, 50) + (String(sampleData[0][sourceCol]).length > 50 ? '...' : '')
            : 'No data';

          return `
            <div class="mb-4 p-4 border border-slate-200 rounded-lg hover:border-slate-300 transition-colors bg-white">
              <div class="mapping-grid">
                <!-- Source Column -->
                <div class="text-left">
                  <div class="flex items-center gap-2 mb-2">
                    <div class="w-6 h-6 bg-zotoks-100 rounded flex items-center justify-center">
                      <svg class="w-3 h-3 text-zotoks-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"></path>
                      </svg>
                    </div>
                    <span class="font-medium text-slate-900 text-sm">${sourceCol}</span>
                  </div>
                  <div class="text-xs text-slate-500 bg-slate-50 rounded px-2 py-1 font-mono max-w-48 truncate">
                    ${sampleValue}
                  </div>
                </div>

                <!-- Arrow -->
                <div class="flex justify-center">
                  <svg class="w-5 h-5 text-slate-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M14 5l7 7m0 0l-7 7m7-7H3"></path>
                  </svg>
                </div>

                <!-- Target Dropdown -->
                <div class="text-left">
                  <div class="relative w-full" data-custom-dropdown>
                    <input type="hidden" name="target-column" value="" data-source="${sourceCol}">
                    <button type="button" class="target-select w-full flex items-center justify-between text-left px-3 py-2 bg-white border border-slate-300 rounded-md focus:outline-none focus:ring-2 focus:ring-zotoks-500 text-sm" aria-haspopup="listbox" aria-expanded="false">
                      <span class="block truncate text-slate-700">Select target column</span>
                      <svg class="w-4 h-4 text-slate-400 transform transition-transform duration-150" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor">
                        <path fill-rule="evenodd" d="M5.23 7.21a.75.75 0 011.06.02L10 11.168l3.71-3.938a.75.75 0 111.08 1.04l-4.25 4.5a.75.75 0 01-1.08 0l-4.25-4.5a.75.75 0 01.02-1.06z" clip-rule="evenodd" />
                      </svg>
                    </button>
                    <ul class="absolute z-10 mt-1 w-full bg-white shadow-lg max-h-60 rounded-md py-1 text-sm ring-1 ring-black ring-opacity-5 overflow-auto focus:outline-none hidden transition-all duration-150 transform origin-top scale-95 opacity-0" tabindex="-1" role="listbox">
                      ${targetOptionsHtml}
                    </ul>
                  </div>
                </div>
              </div>
            </div>
          `;
        }).join('');

        // Single DOM write
        container.innerHTML = allRowsHtml;

        // OPTIMIZATION 3: Setup dropdowns after HTML injection (no staggered timeouts)
        const dropdowns = container.querySelectorAll('[data-custom-dropdown]');
        dropdowns.forEach(dropdown => {
          setupCustomDropdown(dropdown);
        });

        // OPTIMIZATION 4: Single fade-in on the whole container
        container.classList.add('fade-in');

        // OPTIMIZATION 5: Defer preview generation until after first paint
        requestAnimationFrame(() => {
          updatePreview();
        });
      }
      
      // ============================================================
      // ADVANCED AUTO-MAPPING ALGORITHM
      // ============================================================

      // Abbreviation map: single token -> one or more words
      const ABBR = {
        cust: 'customer',
        cid: 'customer id',
        fname: 'first name',
        lname: 'last name',
        qty: 'quantity',
        amt: 'amount',
        no: 'number',
        num: 'number',
        dt: 'date',
        ts: 'timestamp',
        addr: 'address',
        bill: 'billing',
        ship: 'shipping',
        mob: 'mobile',
        ph: 'phone',
        tel: 'phone',
        emailaddr: 'email address',
        phoneno: 'phone number',
        shipaddr: 'shipping address',
        billaddr: 'billing address',
        custid: 'customer id',
        orderdt: 'order date',
        createdts: 'created timestamp',
        createdtimestamp: 'created timestamp',
        tripid: 'trip id',
        orderid: 'order id'
      };

      // Synonym / canonicalization map: token -> canonical token
      const SYN = {
        phone: 'phone',
        mobile: 'phone',
        number: 'number',
        no: 'number',
        email: 'email',
        mail: 'email',
        addr: 'address',
        address: 'address',
        shipping: 'shipping',
        ship: 'shipping',
        billing: 'billing',
        bill: 'billing',
        date: 'date',
        dt: 'date',
        ts: 'timestamp',
        timestamp: 'timestamp',
        state: 'state',
        status: 'status',
        id: 'id',
        qty: 'quantity',
        amount: 'amount',
        customer: 'customer',
        cust: 'customer',
        order: 'order',
        trip: 'trip',
        created: 'created',
        updated: 'updated'
      };

      function simpleStem(token) {
        // very light stemming: plurals etc.
        if (token.endsWith('ies') && token.length > 4) {
          return token.slice(0, -3) + 'y'; // companies -> company
        }
        if (token.endsWith('s') && !token.endsWith('ss') && token.length > 3) {
          return token.slice(0, -1); // names -> name, addresses -> addresse (good enough for overlap)
        }
        return token;
      }

      function tokenize(name) {
        if (!name) return [];
        let s = name.trim();

        // Split camelCase / PascalCase / digit boundaries
        s = s.replace(/([a-z0-9])([A-Z])/g, '$1 $2');
        s = s.replace(/([A-Za-z])([0-9])/g, '$1 $2');
        s = s.replace(/([0-9])([A-Za-z])/g, '$1 $2');

        s = s.toLowerCase();
        // Replace non-alphanumeric (incl. _, -, spaces) with space
        s = s.replace(/[^a-z0-9]+/g, ' ');

        const rawTokens = s.split(/\s+/).filter(Boolean);
        const expanded = [];

        // 1) Expand abbreviations (can produce multiple tokens)
        rawTokens.forEach(t => {
          if (ABBR[t]) {
            const exp = ABBR[t].toLowerCase().replace(/[^a-z0-9]+/g, ' ');
            exp.split(/\s+/).filter(Boolean).forEach(et => expanded.push(et));
          } else {
            expanded.push(t);
          }
        });

        // 2) Apply synonyms / canonicalization + stemming
        const canonical = expanded.map(t => {
          const base = SYN[t] || t;
          return simpleStem(base);
        });

        return canonical;
      }

      function normalizeName(name) {
        const tokens = tokenize(name);
        return {
          normalized: tokens.join(' '),
          tokens
        };
      }

      function jaccardOverlap(srcTokens, tgtTokens) {
        if (!srcTokens.length || !tgtTokens.length) return 0;
        const srcSet = new Set(srcTokens);
        const tgtSet = new Set(tgtTokens);
        let overlap = 0;
        srcSet.forEach(t => {
          if (tgtSet.has(t)) overlap++;
        });
        const denom = Math.max(srcSet.size, tgtSet.size);
        return denom === 0 ? 0 : overlap / denom;
      }

      // Levenshtein distance
      function levenshtein(a, b) {
        const m = a.length, n = b.length;
        if (m === 0) return n;
        if (n === 0) return m;
        const dp = new Array(n + 1);
        for (let j = 0; j <= n; j++) dp[j] = j;
        for (let i = 1; i <= m; i++) {
          let prev = dp[0];
          dp[0] = i;
          for (let j = 1; j <= n; j++) {
            const tmp = dp[j];
            if (a[i - 1] === b[j - 1]) {
              dp[j] = prev;
            } else {
              dp[j] = Math.min(prev + 1, dp[j] + 1, dp[j - 1] + 1);
            }
            prev = tmp;
          }
        }
        return dp[n];
      }

      function levenshteinSim(a, b) {
        if (!a || !b) return 0;
        const maxLen = Math.max(a.length, b.length);
        if (maxLen === 0) return 1;
        const dist = levenshtein(a, b);
        return 1 - dist / maxLen;
      }

      function buildTargetIndex(targetCols) {
        const index = [];
        const exactMap = Object.create(null);
        targetCols.forEach((name, idx) => {
          const info = normalizeName(name);
          const entry = {
            original: name,
            normalized: info.normalized,
            tokens: info.tokens,
            index: idx
          };
          index.push(entry);
          if (info.normalized) {
            exactMap[info.normalized] = entry;
          }
        });
        return { index, exactMap };
      }

      // Weighted scoring with uniqueness lock per target
      function performAutoMapping(sourceCols, targetCols, threshold = 0.5) {
        const { index: targetIndex, exactMap } = buildTargetIndex(targetCols);
        const mappings = [];
        const usedTargetIndices = new Set();

        sourceCols.forEach((srcName) => {
          const srcInfo = normalizeName(srcName);
          const srcNorm = srcInfo.normalized;
          const srcTokens = srcInfo.tokens;

          let bestTarget = null;
          let bestScore = 0;

          // 1) Exact normalized match via hashmap (strongest signal)
          if (srcNorm && exactMap[srcNorm] && !usedTargetIndices.has(exactMap[srcNorm].index)) {
            bestTarget = exactMap[srcNorm];
            bestScore = 1.0;
          } else {
            // 2) Weighted token overlap + prefix + fuzzy (fallback)
            for (const tgt of targetIndex) {
              if (usedTargetIndices.has(tgt.index)) continue;

              const overlap = jaccardOverlap(srcTokens, tgt.tokens);

              // Prefix boost: same first token
              const prefixMatch =
                srcTokens.length && tgt.tokens.length && srcTokens[0] === tgt.tokens[0]
                  ? 1
                  : 0;

              // Fuzzy similarity only when no token overlap
              let fuzzy = 0;
              if (overlap === 0) {
                const a = srcNorm;
                const b = tgt.normalized;
                if (a && b) {
                  fuzzy = levenshteinSim(a, b);
                }
              }

              // Weighted score
              const score =
                overlap * 0.7 +
                prefixMatch * 0.2 +
                fuzzy * 0.3;

              if (score > bestScore) {
                bestScore = score;
                bestTarget = tgt;
              }
            }
          }

          if (bestTarget && bestScore >= threshold) {
            mappings.push({
              source: srcName,
              target: bestTarget.original,
              score: bestScore
            });
            usedTargetIndices.add(bestTarget.index);
          } else {
            mappings.push({
              source: srcName,
              target: '',
              score: 0
            });
          }
        });

        return mappings;
      }

      function autoMapColumns() {
        // Add animation to the auto map button
        const autoMapButton = document.querySelector('button[onclick="autoMapColumns()"]');
        if (autoMapButton) {
          autoMapButton.classList.add('sync-button-pressed');
          setTimeout(() => {
            autoMapButton.classList.remove('sync-button-pressed');
          }, 1500);
        }

        // Perform advanced auto-mapping
        const mappings = performAutoMapping(sourceColumns, targetColumns, 0.5);

        // Apply mappings to UI
        const dropdowns = document.querySelectorAll('[data-custom-dropdown]');
        let mappedCount = 0;

        dropdowns.forEach(dropdown => {
          const hiddenInput = dropdown.querySelector('input[type="hidden"]');
          const sourceCol = hiddenInput.getAttribute('data-source');
          const buttonText = dropdown.querySelector('button span');

          // Find mapping for this source column
          const mapping = mappings.find(m => m.source === sourceCol);

          if (mapping && mapping.target) {
            hiddenInput.value = mapping.target;
            buttonText.textContent = mapping.target;
            mappedCount++;
          }
        });

        updatePreview();
        // Only show toast if significant number of mappings were made
        if (mappedCount > 0) {
          showToast(`Auto-mapped ${mappedCount} columns`, 'success');
        }
      }
      
      function updatePreview() {
        const table = document.getElementById('previewTable');
        const mappings = getMappings();
        
        // Update stats
        updateStats(mappings);
        
        // Clear table
        table.innerHTML = '';
        
        // Create header row
        const headerRow = document.createElement('tr');
        headerRow.className = 'bg-slate-50 border-b border-slate-200';
        targetColumns.forEach(col => {
          const th = document.createElement('th');
          th.className = 'px-4 py-3 text-left text-xs font-medium text-slate-700 uppercase tracking-wider';
          th.textContent = col;
          
          // Highlight mapped columns
          const isMapped = mappings.some(m => m.target === col);
          if (isMapped) {
            th.classList.add('bg-zotoks-50', 'text-zotoks-800');
          }
          
          headerRow.appendChild(th);
        });
        table.appendChild(headerRow);
        
        // Create data rows
        const rowsToShow = Math.min(3, sampleData.length);
        for (let i = 0; i < rowsToShow; i++) {
          const dataRow = document.createElement('tr');
          dataRow.className = 'border-b border-slate-100 hover:bg-slate-50';
          
          targetColumns.forEach((targetCol) => {
            const td = document.createElement('td');
            td.className = 'px-4 py-3 text-sm text-slate-900';
            
            // Find mapped value
            const mapping = mappings.find(m => m.target === targetCol);
            let value = '';
            
            if (mapping && mapping.source && sampleData[i].hasOwnProperty(mapping.source)) {
              value = sampleData[i][mapping.source] || '';
            }
            
            if (value) {
              // Truncate long values
              const displayValue = String(value).length > 30 ? String(value).substring(0, 30) + '...' : String(value);
              td.textContent = displayValue;
              td.title = String(value); // Full value in tooltip
            } else {
              td.innerHTML = '<span class="text-slate-400 italic text-xs">—</span>';
              td.classList.add('bg-slate-25');
            }
            
            dataRow.appendChild(td);
          });
          
          table.appendChild(dataRow);
        }
        
        document.getElementById('previewRows').textContent = rowsToShow;
      }
      
      function updateStats(mappings) {
        const mappedCount = mappings.length;
        const unmappedCount = sourceColumns.length - mappedCount;
        
        document.getElementById('mappedCount').textContent = mappedCount;
        document.getElementById('unmappedCount').textContent = unmappedCount;
      }
      
      function getMappings() {
        const hiddenInputs = document.querySelectorAll('[data-custom-dropdown] input[type="hidden"]');
        const mappings = [];

        hiddenInputs.forEach(input => {
          if (input.value) {
            mappings.push({
              source: input.getAttribute('data-source'),
              target: input.value,
              source_column: input.getAttribute('data-source'),
              target_column: input.value
            });
          }
        });

        return mappings;
      }

      // Custom dropdown functionality
      function setupCustomDropdown(dropdown) {
        const button = dropdown.querySelector('button');
        const menu = dropdown.querySelector('ul');
        const hiddenInput = dropdown.querySelector('input[type="hidden"]');
        const options = dropdown.querySelectorAll('li[role="option"]');

        // Toggle dropdown on button click
        button.addEventListener('click', (e) => {
          e.preventDefault();
          toggleDropdown(dropdown);
        });

        // Handle option selection
        options.forEach(option => {
          option.addEventListener('click', () => {
            const buttonText = dropdown.querySelector('button span');
            const value = option.getAttribute('data-value');

            buttonText.textContent = option.textContent.trim();
            hiddenInput.value = value;

            closeDropdown(dropdown);
            updatePreview();
          });
        });
      }

      function toggleDropdown(dropdown) {
        // Close all other dropdowns first
        document.querySelectorAll('[data-custom-dropdown].open').forEach(otherDropdown => {
          if (otherDropdown !== dropdown) {
            closeDropdown(otherDropdown);
          }
        });

        dropdown.classList.toggle('open');
        const button = dropdown.querySelector('button');
        const menu = dropdown.querySelector('ul');
        const arrow = dropdown.querySelector('svg');

        const isOpen = dropdown.classList.contains('open');
        button.setAttribute('aria-expanded', isOpen);

        if (isOpen) {
          menu.classList.remove('hidden');
          setTimeout(() => {
            menu.classList.remove('scale-95', 'opacity-0');
            menu.classList.add('scale-100', 'opacity-100');
          }, 10);
          arrow.style.transform = 'rotate(180deg)';
        } else {
          menu.classList.add('scale-95', 'opacity-0');
          menu.classList.remove('scale-100', 'opacity-100');
          setTimeout(() => {
            menu.classList.add('hidden');
          }, 150);
          arrow.style.transform = 'rotate(0deg)';
        }
      }

      function closeDropdown(dropdown) {
        dropdown.classList.remove('open');
        const button = dropdown.querySelector('button');
        const menu = dropdown.querySelector('ul');
        const arrow = dropdown.querySelector('svg');

        button.setAttribute('aria-expanded', 'false');
        menu.classList.add('scale-95', 'opacity-0');
        menu.classList.remove('scale-100', 'opacity-100');
        setTimeout(() => {
          menu.classList.add('hidden');
        }, 150);
        arrow.style.transform = 'rotate(0deg)';
      }

      // Close dropdowns when clicking outside
      document.addEventListener('click', (e) => {
        if (!e.target.closest('[data-custom-dropdown]')) {
          document.querySelectorAll('[data-custom-dropdown].open').forEach(dropdown => {
            closeDropdown(dropdown);
          });
        }
      });
      
      function showToast(message, type) {
        const toast = document.createElement('div');
        toast.className = `fixed top-4 right-4 px-4 py-3 rounded-md font-medium z-40 transition-all transform translate-x-full opacity-0 ${
          type === 'success' ? 'bg-green-600 text-white' : 
          type === 'info' ? 'bg-zotoks-600 text-white' : 
          type === 'error' ? 'bg-red-600 text-white' : 'bg-slate-600 text-white'
        }`;
        toast.textContent = message;
        document.body.appendChild(toast);
        
        // Animate in
        setTimeout(() => {
          toast.style.transform = 'translateX(0)';
          toast.style.opacity = '1';
        }, 100);
        
        // Animate out
        setTimeout(() => {
          toast.style.opacity = '0';
          toast.style.transform = 'translateX(100%)';
          setTimeout(() => toast.remove(), 300);
        }, 3000);
      }
      
      function showLoading(show) {
        const loadingDiv = document.getElementById('loadingDiv');
        const loadingTitle = document.getElementById('loadingTitle');
        const loadingMessage = document.getElementById('loadingMessage');

        if (show) {
          if (isExportMode) {
            loadingTitle.textContent = 'Uploading Zötok Data';
            loadingMessage.textContent = 'Applying column mappings and uploading your data...';
          } else {
            loadingTitle.textContent = 'Importing Zötok Data';
            loadingMessage.textContent = 'Applying column mappings and importing your data...';
          }
        }

        loadingDiv.classList.toggle('hidden', !show);
      }

      function showSuccess(message, show) {
        const successDiv = document.getElementById('successDiv');
        const successTitle = document.getElementById('successTitle');
        const successMessage = document.getElementById('successMessage');

        if (show) {
          if (isExportMode) {
            successTitle.textContent = 'Upload Successful!';
          } else {
            successTitle.textContent = 'Import Successful!';
          }
          successMessage.textContent = message;
          successDiv.classList.remove('hidden');
        } else {
          successDiv.classList.add('hidden');
        }
      }

      function proceedWithMapping() {
        const mappings = getMappings();

        if (mappings.length === 0) {
          showToast('Please map at least one column before proceeding.', 'error');
          return;
        }

        showLoading(true);

        if (isExportMode) {
          // Export mode - call export function based on endpoint
          const exportAction = `export${endpoint.charAt(0).toUpperCase()}${endpoint.slice(1)}WithMappings`;
          google.script.run
            .withSuccessHandler(handleExportResult)
            .withFailureHandler(handleError)
            .dispatch(exportAction, { mappings: mappings });
        } else {
          // Import mode - call import function
          google.script.run
            .withSuccessHandler(handleImportResult)
            .withFailureHandler(handleError)
            .dispatch('importWithMappings', { targetSheetName, endpoint, period: parseInt(period), mappings });
        }
      }

      function handleImportResult(result) {
        showLoading(false);

        if (result.success) {
          const message = result.recordCount !== undefined
            ? `Successfully synced ${result.recordCount} records`
            : `Successfully imported ${result.rowCount} rows of ${result.endpoint} data`;
          showSuccess(message, true);

          // Auto-close after brief delay to show success
          setTimeout(() => {
            google.script.host.close();
          }, 2500);
        } else {
          showToast('Error: ' + result.message, 'error');
        }
      }

      function handleExportResult(result) {
        showLoading(false);
        // Export function handles its own UI alerts, just close dialog
        google.script.host.close();
      }
      
      function handleError(error) {
        showLoading(false);
        showToast('Error: ' + error.message, 'error');
      }
      
      function cancelMapping() {
        google.script.host.close();
      }
      
      // Initialize on load
      initializeMappings();
    </script>
  </body>
</html>